<!--
date=2022-09-07
topic=Hyperledger
-->

<img class='full' src='assets/posts/guides/011_hyperledger_indy/thumbnail.png'>

# Hyperledger Indy

Indy is a public ledger designed and only for privacy-preserving self-sovereign identity. Indy provides a **public permissioned** distributed ledger for managing decentralized identities.

## DID Creation
Indy's Acapy agent posesses the capability to create a new DID by calling its <code>/wallet/did/create</code> endpoint with a specified method just as <code>sov</code> and key_type like <code>ed25519</code>. The endpoint returns a JSON containing the newly created DID which is private by default meaning that it has not yet been written to any ledger. There is no need for an identity holder to publish its DID to a ledger and can remain private as it is. On the other hand, if an agent is indended to act as issuer or verifier, it is required to push a DID.

Alongside the DID, a private and public key (verkey) get created. The private key is managed by the agent and does not exposed at any time. The public key can freely be shared and published alongside the DID to a ledger. The key pair is generated by Edwards-Curve Digital Signature Algorithm (EdDSA), please refer to https://www.rfc-editor.org/rfc/rfc8032 for the exact specification.

After a private DID got created, it is possible to publish the DID to a ledger using the <code>/ledger/register-nym</code> endpoint. The endpoint only requires two parameters, the DID itself and its corresponding verkey aka public key. After having called the endpoint, a new NYM should have been published to the ledger. Using a DID resolver, supporting the <code>sov</code> or the upcoming <code>indy</code> methods, it is possible to retrieve a DID document corresponding to the NYM on the ledger.

At the current stage, a service endpoint corresponding to the published DID can be set by calling <code>/wallet/set-did-endpoint</code>. The service endpoint needs to be an agent such as Indy's Akapy agent that can to connection, credential or proof requests.

## Data Management
As Indy's core purpose is to facilitate privacy-preserving self-sovereign identity, no personal information get stored on a ditributed ledger, not even encrypted. Personal data get exclusively exchanged through peer-to-peer connections between agents acting on behalf of identity holders and issuing/verifying entities. This setup allows the exchange of sensitive personal data without relying on a centralized authority and prevents to correlate meta information commonly written to distributed ledgers. 

Personal data, issued through verifiable credentials are stored exclusively in **wallets** attached to an agent. However, the term wallet might be somewhat misleading, as a Indy wallet does not query a transaction history that is stored on a distributed ledger, but stores credentials locally. Indy's SDK (software development kit) supports to wallet types, namely **Indy** and **Aries Askar**. The **Askar** wallet provides a noticably better performance compared to the older Indy wallet implementation. **Askar** also offers a pluggable database design allowing to use either **SQLite** and **PostgreSQL** to actually store encrypted credentials.

Next to the secure storage capabilities, the wallet layer provides cryptographic support for credentials building on the Hyperledger Ursa cryptographic library. However, it  might adequate to note that by abstaining to write any encrypted personal information to aledger, Indy-based identity management systems become relient on the availablity of agents acting on behalf of identity holders. If an agent becomes inaccessable to destroyed, all recieved credentials are lost to the identity holders, if not sufficiently backed up.

## Credential Issuance
Although a distributed ledger is not envolved in storing personal information, Indy's distributed ledgers play a paramount role in ensuring the authenticitiy of verifiable credentials. Among others, there are three key information that get written to Indy's domain ledger, which are the <code>NYM</code> and the corresponding service endpoint of an issuer, the <code>SCHEMA</code> and <code>CLAIM_DEF</code> (Credential definition) and finally revocation related information stored as <code>REVOC_REG_DEF<code> and <code>REVOC_REG_ENTRY<code> transactions.

Before a verifiable credential can be issued, its schema defining a range of attributes and credential definition building on top of the defined schema need to be published to Indy's domain ledger. Schemas can be reused by any party to create their own credential definitions. However, a credential definition is bound to one and only one issuer. After a credential definition got published to a ledger, a credential can be send to an identity holder by calling the <code>/issue-credential/send</code> endpoint. The endpoint requires among others, a connection_id referring to an active connection to a holder, a credential_proposal containing the attributes and their corresponding values and a cred_def_id referring to the credential that should be issued.

The issuer signs the credential by its private key and sends it to the holder which is free to either accept or reject the offered credential. If the holder decides to accept the offer, the credential gets persistently stored in the holders wallet. If a proof is requested from a verfier, a credential need to conform with the definition written to the distributed ledger and signed by the correct issuing party. For a more information on the credential issuance process, please refer to https://github.com/hyperledger/aries-rfcs/blob/main/features/0036-issue-credential/README.md.

## Privacy Considerations
With it's current implementation, Indy accomplishes largely its goal to preserve privacy, mainly due be to the fact that no personal data get written to a distributed ledger. In addition, by utilizing peer-to-peer connections, no centralized authority is involved in the exchange of personal data. Furthermore, that approves largely prevents the correlation of meta data such as transaction ids or public keys of counterparties. However, it should be noted that DIDs of issuing entries get published to Indy's domain ledger, get resolved to DID Documents that are publicly readable and therefore potentially suspectable to surveillance. In the same way any new schemas and credential definition get published to the domain ledger and be accessed by anyone.

While Indy's core design is highly privacy preserving, it comes with the downside of introducing agents, meaning software applications able to receive verifyable credentials and presenting them. They utilize traditional login mechanisms and are therefore to some extend prone to identiy theft. Let's assume an identity holder uses it's Lissi Wallet on a personal smartphone, which gets stolen and the password brute-forced or guessed, it becomes possible for a malicious third-party to read the content of all credentials issued to the identity holder.

## Proofs Presentations
After a verifiable credential got signed with the private key of the issuer and issued to an identity holder, the holder is free to present the credential in any proof request that the entity may receive. The issuer of a credential does not get informed if a credential gets used within a proof presentation between the credential holder and a verifying third-party. If a credential holder decides to disclose (some) attributes stored in a verifiable credential to a verifier sending a proof request, the holder's agent does not only sends the actual attribute values, but also a corresponding cryptographic signature allowing the verifier to verify the authenticity of the credential by applying the issuer's public key stored on the ledger. For further information on the proof presentation process, please refer to https://github.com/hyperledger/aries-rfcs/blob/main/features/0037-present-proof/README.md.